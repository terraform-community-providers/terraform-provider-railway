"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

type AccessRule {
  disallowed: String
}

enum ActiveFeatureFlag {
  BUCKETS
  HTTP_SERVICE_METRICS
  IPv4_PRIVATE_NETWORKS
  MONOREPO_SUPPORT
  PRIORITY_BOARDING
  RAW_SQL_QUERIES
  UNIFIED_TEMPLATE_EDITOR
}

enum ActivePlatformFlag {
  ALLOW_REPLICA_METRICS
  BUCKETS
  DEMO_PERCENTAGE_ROLLOUT
  ENABLE_RAW_SQL_QUERIES
  MONOREPO_SUPPORT
  UPDATED_VM_QUERIES
  USE_GH_WEBHOOKS_FOR_CHANGE_DETECTION
  VM_TIME_RANGE_QUERY
}

enum ActiveServiceFeatureFlag {
  COPY_VOLUME_TO_ENVIRONMENT
  PLACEHOLDER
  USE_GH_WEBHOOKS_FOR_CHANGE_DETECTION
}

type AdoptionInfo implements Node {
  adoptionLevel: Float
  createdAt: DateTime!
  deltaLevel: Float
  id: ID!
  matchedIcpEmail: String
  monthlyEstimatedUsage: Float
  numConfigFile: Int!
  numCronSchedule: Int!
  numDeploys: Int!
  numEnvs: Int!
  numFailedDeploys: Int!
  numHealthcheck: Int!
  numIconConfig: Int!
  numRegion: Int!
  numReplicas: Int!
  numRootDirectory: Int!
  numSeats: Int!
  numServices: Int!
  numVariables: Int!
  numWatchPatterns: Int!
  totalCores: Float
  totalDisk: Float
  totalNetwork: Float
  updatedAt: DateTime!
  workspace: Workspace!
}

"""The aggregated usage of a single measurement."""
type AggregatedUsage {
  """The measurement that was aggregated."""
  measurement: MetricMeasurement!

  """
  The tags that were used to group the metric. Only the tags that were used in the `groupBy` will be present.
  """
  tags: MetricTags!

  """The aggregated value."""
  value: Float!
}

type AllDomains {
  customDomains: [CustomDomain!]!
  serviceDomains: [ServiceDomain!]!
}

type ApiToken implements Node {
  displayToken: String!
  id: ID!
  name: String!
  workspaceId: String
}

input ApiTokenCreateInput {
  name: String!
  workspaceId: String
}

type ApiTokenRateLimit {
  remainingPoints: Int!
  resetsAt: String!
}

type AppliedByMember {
  avatar: String
  email: String!
  id: String!
  name: String
  username: String
}

type BanReasonHistory implements Node {
  actor: User
  banReason: String
  createdAt: DateTime!
  id: ID!
}

input BaseEnvironmentOverrideInput {
  baseEnvironmentOverrideId: String
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""The billing period for a customers subscription."""
type BillingPeriod {
  end: DateTime!
  start: DateTime!
}

enum Builder {
  HEROKU
  NIXPACKS
  PAKETO
  RAILPACK
}

scalar CanvasConfig

enum CDNProvider {
  DETECTED_CDN_PROVIDER_CLOUDFLARE
  DETECTED_CDN_PROVIDER_UNSPECIFIED
  UNRECOGNIZED
}

type CertificatePublicData {
  domainNames: [String!]!
  expiresAt: DateTime
  fingerprintSha256: String!
  issuedAt: DateTime
  keyType: KeyType!
}

enum CertificateStatus {
  CERTIFICATE_STATUS_TYPE_ISSUE_FAILED
  CERTIFICATE_STATUS_TYPE_ISSUING
  CERTIFICATE_STATUS_TYPE_UNSPECIFIED
  CERTIFICATE_STATUS_TYPE_VALID
  CERTIFICATE_STATUS_TYPE_VALIDATING_OWNERSHIP
  UNRECOGNIZED
}

type CnameCheck {
  link: String
  message: String!
  status: CnameCheckStatus!
}

enum CnameCheckStatus {
  ERROR
  INFO
  INVALID
  VALID
  WAITING
}

type Container implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  environment: Environment!
  environmentId: String!
  id: ID!
  migratedAt: DateTime
  plugin: Plugin!
  pluginId: String!
}

type Credit implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  memo: String
  type: CreditType!
  updatedAt: DateTime!
}

enum CreditType {
  APPLIED
  CREDIT
  DEBIT
  STRIPE
  TRANSFER
  WAIVED
}

type CustomDomain implements Domain {
  cnameCheck: CnameCheck! @deprecated(reason: "Use the `status` field instead.")
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  status: CustomDomainStatus!
  targetPort: Int
  updatedAt: DateTime
}

input CustomDomainCreateInput {
  domain: String!
  environmentId: String!
  projectId: String!
  serviceId: String!
  targetPort: Int
}

type CustomDomainStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
}

type Customer implements Node {
  """
  The total amount of credits that have been applied during the current billing period.
  """
  appliedCredits: Float!
  billingAddress: CustomerAddress
  billingEmail: String
  billingPeriod: BillingPeriod!

  """The total amount of unused credits for the customer."""
  creditBalance: Float!
  credits(after: String, before: String, first: Int, last: Int): CustomerCreditsConnection!

  """
  The current usage for the customer. This value is cached and may not be up to date.
  """
  currentUsage: Float!
  defaultPaymentMethod: PaymentMethod
  defaultPaymentMethodId: String
  hasExhaustedFreePlan: Boolean!
  id: ID!
  invoices: [CustomerInvoice!]!
  isPrepaying: Boolean!
  isTrialing: Boolean!
  isUsageSubscriber: Boolean!
  isWithdrawingToCredits: Boolean!
  planLimitOverride: PlanLimitOverride
  remainingUsageCreditBalance: Float!
  state: SubscriptionState!
  stripeCustomerId: String!
  subscriptions: [CustomerSubscription!]!
  supportedWithdrawalPlatforms: [WithdrawalPlatformTypes!]!
  taxIds: [CustomerTaxId!]!
  trialDaysRemaining: Int!
  usageLimit: UsageLimit
  workspace: Workspace!
}

type CustomerAddress {
  city: String
  country: String
  line1: String
  line2: String
  name: String
  postalCode: String
  state: String
}

type CustomerCreditsConnection {
  edges: [CustomerCreditsConnectionEdge!]!
  pageInfo: PageInfo!
}

type CustomerCreditsConnectionEdge {
  cursor: String!
  node: Credit!
}

type CustomerInvoice {
  amountDue: Float!
  amountPaid: Float!
  hostedURL: String
  invoiceId: String!
  items: [SubscriptionItem!]!
  lastPaymentError: String
  paymentIntentStatus: String
  pdfURL: String
  periodEnd: String!
  periodStart: String!
  reissuedInvoiceFrom: String
  reissuedInvoiceOf: String
  status: String
  subscriptionId: String
  total: Int!
}

type CustomerSubscription {
  billingCycleAnchor: DateTime!
  cancelAt: String
  cancelAtPeriodEnd: Boolean!
  couponId: String
  discounts: [SubscriptionDiscount!]!
  id: String!
  items: [SubscriptionItem!]!
  latestInvoiceId: String!
  nextInvoiceCurrentTotal: Int!
  nextInvoiceDate: String!
  status: String!
}

type CustomerTaxId {
  id: String!
  type: String!
  value: String!
}

input customerTogglePayoutsToCreditsInput {
  isWithdrawingToCredits: Boolean!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Deployment implements Node {
  canRedeploy: Boolean!
  canRollback: Boolean!
  createdAt: DateTime!
  creator: DeploymentCreator

  """Check if a deployment's instances have all stopped"""
  deploymentStopped: Boolean!
  environment: Environment!
  environmentId: String!
  id: ID!
  instances: [DeploymentDeploymentInstance!]!
  meta: DeploymentMeta
  projectId: String!
  service: Service!
  serviceId: String
  snapshotId: String
  sockets: [DeploymentSocket!]!
  staticUrl: String
  status: DeploymentStatus!
  statusUpdatedAt: DateTime
  suggestAddServiceDomain: Boolean!
  updatedAt: DateTime!
  url: String
}

type DeploymentCreator {
  avatar: String
  email: String!
  id: String!
  name: String
}

type DeploymentDeploymentInstance {
  id: String!
  status: DeploymentInstanceStatus!
}

type DeploymentEvent implements Node {
  completedAt: DateTime
  createdAt: DateTime!
  id: ID!
  payload: DeploymentEventPayload
  step: DeploymentEventStep!
}

type DeploymentEventPayload {
  error: String
}

enum DeploymentEventStep {
  BUILD_IMAGE
  CREATE_CONTAINER
  DRAIN_INSTANCES
  HEALTHCHECK
  MIGRATE_VOLUMES
  PRE_DEPLOY_COMMAND
  PUBLISH_IMAGE
  SNAPSHOT_CODE
  WAIT_FOR_DEPENDENCIES
}

type DeploymentInstanceExecution implements Node {
  completedAt: DateTime
  createdAt: DateTime!
  deploymentId: String!
  deploymentMeta: DeploymentMeta!
  id: ID!
  status: DeploymentInstanceStatus!
  updatedAt: DateTime!
}

input DeploymentInstanceExecutionCreateInput {
  serviceInstanceId: String!
}

input DeploymentInstanceExecutionInput {
  deploymentId: String!
}

input DeploymentInstanceExecutionListInput {
  environmentId: String!
  serviceId: String!
}

enum DeploymentInstanceStatus {
  CRASHED
  CREATED
  EXITED
  INITIALIZING
  REMOVED
  REMOVING
  RESTARTING
  RUNNING
  SKIPPED
  STOPPED
}

input DeploymentListInput {
  environmentId: String
  includeDeleted: Boolean
  projectId: String
  serviceId: String
  status: DeploymentStatusInput
}

scalar DeploymentMeta

type DeploymentSnapshot implements Node {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  variables: EnvironmentVariables!
}

type DeploymentSocket {
  ipv6: Boolean!
  port: Int!
  processName: String!
  updatedAt: Int!
}

enum DeploymentStatus {
  BUILDING
  CRASHED
  DEPLOYING
  FAILED
  INITIALIZING
  NEEDS_APPROVAL
  QUEUED
  REMOVED
  REMOVING
  SKIPPED
  SLEEPING
  SUCCESS
  WAITING
}

input DeploymentStatusInput {
  in: [DeploymentStatus!]
  notIn: [DeploymentStatus!]
}

type DeploymentTrigger implements Node {
  baseEnvironmentOverrideId: String
  branch: String!
  checkSuites: Boolean!
  environmentId: String!
  id: ID!
  projectId: String!
  provider: String!
  repository: String!
  serviceId: String
  validCheckSuites: Int!
}

input DeploymentTriggerCreateInput {
  branch: String!
  checkSuites: Boolean
  environmentId: String!
  projectId: String!
  provider: String!
  repository: String!
  rootDirectory: String
  serviceId: String!
}

input DeploymentTriggerUpdateInput {
  branch: String
  checkSuites: Boolean
  repository: String
  rootDirectory: String
}

scalar DisplayConfig

enum DNSRecordPurpose {
  DNS_RECORD_PURPOSE_ACME_DNS01_CHALLENGE
  DNS_RECORD_PURPOSE_TRAFFIC_ROUTE
  DNS_RECORD_PURPOSE_UNSPECIFIED
  UNRECOGNIZED
}

type DNSRecords {
  currentValue: String!
  fqdn: String!
  hostlabel: String!
  purpose: DNSRecordPurpose!
  recordType: DNSRecordType!
  requiredValue: String!
  status: DNSRecordStatus!
  zone: String!
}

enum DNSRecordStatus {
  DNS_RECORD_STATUS_PROPAGATED
  DNS_RECORD_STATUS_REQUIRES_UPDATE
  DNS_RECORD_STATUS_UNSPECIFIED
  UNRECOGNIZED
}

enum DNSRecordType {
  DNS_RECORD_TYPE_A
  DNS_RECORD_TYPE_CNAME
  DNS_RECORD_TYPE_NS
  DNS_RECORD_TYPE_UNSPECIFIED
  UNRECOGNIZED
}

type DockerComposeImport {
  errors: [String!]!
  patch: EnvironmentConfig
}

interface Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  targetPort: Int
  updatedAt: DateTime
}

type DomainAvailable {
  available: Boolean!
  message: String!
}

type DomainWithStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
  domain: Domain
}

type EgressGateway {
  ipv4: String!
  region: String!
}

input EgressGatewayCreateInput {
  environmentId: String!
  region: String
  serviceId: String!
}

input EgressGatewayServiceTargetInput {
  environmentId: String!
  serviceId: String!
}

type Environment implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentsConnection!
  id: ID!
  isEphemeral: Boolean!
  meta: EnvironmentMeta
  name: String!
  projectId: String!
  serviceInstances(after: String, before: String, first: Int, last: Int): EnvironmentServiceInstancesConnection!
  sourceEnvironment: Environment
  unmergedChangesCount: Int
  updatedAt: DateTime!
  variables(after: String, before: String, first: Int, last: Int): EnvironmentVariablesConnection!
  volumeInstances(after: String, before: String, first: Int, last: Int): EnvironmentVolumeInstancesConnection!
}

scalar EnvironmentConfig

input EnvironmentCreateInput {
  """
  If true, the changes will be applied in the background and the mutation will
  return immediately. If false, the mutation will wait for the changes to be
  applied before returning.
  """
  applyChangesInBackground: Boolean
  ephemeral: Boolean
  name: String!
  projectId: String!

  """When committing the changes immediately, skip any initial deployments."""
  skipInitialDeploys: Boolean

  """
  Create the environment with all of the services, volumes, configuration, and variables from this source environment.
  """
  sourceEnvironmentId: String

  """
  Stage the initial changes for the environment. If false (default), the changes will be committed immediately.
  """
  stageInitialChanges: Boolean
}

type EnvironmentDeploymentsConnection {
  edges: [EnvironmentDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type EnvironmentDeploymentTriggersConnection {
  edges: [EnvironmentDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type EnvironmentMeta {
  baseBranch: String
  branch: String
  prCommentId: Int
  prNumber: Int
  prRepo: String
  prTitle: String
}

type EnvironmentPatch implements Node {
  appliedAt: DateTime
  appliedBy: AppliedByMember
  createdAt: DateTime!
  environment: Environment!
  environmentId: String!
  id: ID!
  lastAppliedError: String
  message: String
  status: EnvironmentPatchStatus!
  updatedAt: DateTime!
}

enum EnvironmentPatchStatus {
  APPLYING
  COMMITTED
  STAGED
}

input EnvironmentRenameInput {
  name: String!
}

type EnvironmentServiceInstancesConnection {
  edges: [EnvironmentServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}

input EnvironmentTriggersDeployInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}

"""
EnvironmentVariables is a custom scalar type that represents a map of environment variables.
"""
scalar EnvironmentVariables

type EnvironmentVariablesConnection {
  edges: [EnvironmentVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}

type EnvironmentVolumeInstancesConnection {
  edges: [EnvironmentVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}

"""The estimated usage of a single measurement."""
type EstimatedUsage {
  """The estimated value."""
  estimatedValue: Float!

  """The measurement that was estimated."""
  measurement: MetricMeasurement!
  projectId: String!
}

type Event implements Node {
  action: String!
  createdAt: DateTime!
  environment: Environment
  environmentId: String
  id: ID!
  object: String!
  payload: JSON
  project: Project!
  projectId: String!
}

input EventFilterInput {
  action: EventStringListFilter
  object: EventStringListFilter
}

input EventStringListFilter {
  in: [String!]
  notIn: [String!]
}

input ExplicitOwnerInput {
  """The ID of the owner"""
  id: String!

  """The type of owner"""
  type: ResourceOwnerType
}

type ExternalWorkspace {
  allowDeprecatedRegions: Boolean
  avatar: String
  banReason: String
  createdAt: DateTime!
  customerId: String
  customerState: SubscriptionState!
  discordRole: String
  hasBAA: Boolean!
  id: String!
  isTrialing: Boolean
  name: String!
  plan: Plan!
  preferredRegion: String
  projects: [Project!]!
  supportTierOverride: String
  teamId: String
}

input FeatureFlagToggleInput {
  flag: ActiveFeatureFlag!
}

type FunctionRuntime {
  """The image of the function runtime"""
  image: String!

  """The latest version of the function runtime"""
  latestVersion: FunctionRuntimeVersion!

  """The name of the function runtime"""
  name: FunctionRuntimeName!

  """The versions of the function runtime"""
  versions: [FunctionRuntimeVersion!]!
}

"""Supported function runtime environments"""
enum FunctionRuntimeName {
  bun
}

type FunctionRuntimeVersion {
  image: String!
  tag: String!
}

type GitHubAccess {
  hasAccess: Boolean!
  isPublic: Boolean!
}

type GitHubBranch {
  name: String!
}

type GitHubRepo {
  defaultBranch: String!
  description: String
  fullName: String!
  id: Int!
  installationId: String!
  isPrivate: Boolean!
  name: String!
  ownerAvatarUrl: String
}

input GitHubRepoDeployInput {
  branch: String
  projectId: String!
  repo: String!
}

input GitHubRepoUpdateInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}

type GitHubRepoWithoutInstallation {
  defaultBranch: String!
  description: String
  fullName: String!
  id: Int!
  isPrivate: Boolean!
  name: String!
}

type HerokuApp {
  id: String!
  name: String!
}

input HerokuImportVariablesInput {
  environmentId: String!
  herokuAppId: String!
  projectId: String!
  serviceId: String!
}

"""The result of a http logs query."""
type HttpLog {
  """The client user agent"""
  clientUa: String!

  """The deployment ID that was requested"""
  deploymentId: String!

  """The deployment instance ID that was requested"""
  deploymentInstanceId: String!

  """The downstream HTTP protocol version"""
  downstreamProto: String!

  """The edge region the client connected to"""
  edgeRegion: String!

  """The requested host"""
  host: String!

  """The http status of the log"""
  httpStatus: Int!

  """The request HTTP method"""
  method: String!

  """The requested path"""
  path: String!

  """The unique request ID"""
  requestId: String!

  """Details about the upstream response"""
  responseDetails: String!

  """Received bytes"""
  rxBytes: Int!

  """The source IP of the request"""
  srcIp: String!

  """The timestamp the log was created"""
  timestamp: String!

  """The total duration the request took"""
  totalDuration: Int!

  """Outgoing bytes"""
  txBytes: Int!

  """The upstream address"""
  upstreamAddress: String!

  """Any upstream errors that occurred"""
  upstreamErrors: String!

  """The upstream HTTP protocol version"""
  upstreamProto: String!

  """How long the upstream request took to respond"""
  upstreamRqDuration: Int!
}

type Incident {
  id: String!
  message: String!
  status: IncidentStatus!
  url: String!
}

enum IncidentStatus {
  IDENTIFIED
  INVESTIGATING
  MONITORING
  RESOLVED
}

type Integration implements Node {
  config: JSON!
  id: ID!
  name: String!
  projectId: String!
}

type IntegrationAuth implements Node {
  id: ID!
  integrations(after: String, before: String, first: Int, last: Int): IntegrationAuthIntegrationsConnection!
  provider: String!
  providerId: String!
}

type IntegrationAuthIntegrationsConnection {
  edges: [IntegrationAuthIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}

type IntegrationAuthIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}

input IntegrationCreateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}

input IntegrationUpdateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}

type InviteCode implements Node {
  code: String!
  createdAt: DateTime!
  id: ID!
  project: Project!
  projectId: String!
  role: ProjectRole!
}

input JobApplicationCreateInput {
  email: String!
  jobId: String!
  name: String!
  why: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

enum KeyType {
  KEY_TYPE_ECDSA
  KEY_TYPE_RSA_2048
  KEY_TYPE_RSA_4096
  KEY_TYPE_UNSPECIFIED
  UNRECOGNIZED
}

"""The result of a logs query."""
type Log {
  """The attributes that were parsed from a structured log"""
  attributes: [LogAttribute!]!

  """The contents of the log message"""
  message: String!

  """The severity of the log message (eg. err)"""
  severity: String

  """The tags that were associated with the log"""
  tags: LogTags

  """The timestamp of the log message in format RFC3339 (nano)"""
  timestamp: String!
}

"""The attributes associated with a structured log"""
type LogAttribute {
  key: String!
  value: String!
}

input LoginSessionAuthInput {
  code: String!
  hostname: String
}

"""The tags associated with a specific log"""
type LogTags {
  deploymentId: String
  deploymentInstanceId: String
  environmentId: String
  pluginId: String @deprecated(reason: "Plugins have been removed")
  projectId: String
  serviceId: String
  snapshotId: String
}

type Maintenance {
  id: String!
  message: String!
  status: MaintenanceStatus!
  url: String!
}

enum MaintenanceStatus {
  COMPLETED
  INPROGRESS
  NOTSTARTEDYET
}

"""A single sample of a metric."""
type Metric {
  """
  The timestamp of the sample. Represented has number of seconds since the Unix epoch.
  """
  ts: Int!

  """The value of the sample."""
  value: Float!
}

"""A thing that can be measured on Railway."""
enum MetricMeasurement {
  BACKUP_USAGE_GB
  CPU_LIMIT
  CPU_USAGE
  CPU_USAGE_2
  DISK_USAGE_GB
  EPHEMERAL_DISK_USAGE_GB
  MEASUREMENT_UNSPECIFIED
  MEMORY_LIMIT_GB
  MEMORY_USAGE_GB
  NETWORK_RX_GB
  NETWORK_TX_GB
  UNRECOGNIZED
}

"""The result of a metrics query."""
type MetricsResult {
  """The measurement of the metric."""
  measurement: MetricMeasurement!

  """
  The tags that were used to group the metric. Only the tags that were used to by will be present.
  """
  tags: MetricTags!

  """The samples of the metric."""
  values: [Metric!]!
}

"""A property that can be used to group metrics."""
enum MetricTag {
  DEPLOYMENT_ID
  DEPLOYMENT_INSTANCE_ID
  ENVIRONMENT_ID
  HOST_TYPE
  KEY_UNSPECIFIED
  PLUGIN_ID
  PROJECT_ID
  REGION
  SERVICE_ID
  UNRECOGNIZED
  VOLUME_ID
  VOLUME_INSTANCE_ID
}

"""The tags that were used to group the metric."""
type MetricTags {
  deploymentId: String
  deploymentInstanceId: String
  environmentId: String
  pluginId: String @deprecated(reason: "Plugins have been removed")
  projectId: String
  region: String
  serviceId: String
  volumeId: String
  volumeInstanceId: String
}

enum MonitorAlertResourceType {
  SERVICE
  VOLUME
}

enum MonitorStatus {
  ALERT
  OK
}

enum MonitorThresholdCondition {
  above
  below
}

type MonitorThresholdConfig {
  condition: MonitorThresholdCondition!
  measurement: MetricMeasurement
  threshold: Float!
  type: String!
}

type Mutation {
  """Creates a new API token."""
  apiTokenCreate(input: ApiTokenCreateInput!): String!

  """Deletes an API token."""
  apiTokenDelete(id: String!): Boolean!

  """Sets the base environment override for a deployment trigger."""
  baseEnvironmentOverride(id: String!, input: BaseEnvironmentOverrideInput!): Boolean!

  """Creates a new custom domain."""
  customDomainCreate(input: CustomDomainCreateInput!): CustomDomain!

  """Deletes a custom domain."""
  customDomainDelete(id: String!): Boolean!

  """Updates a custom domain."""
  customDomainUpdate(environmentId: String!, id: String!, targetPort: Int): Boolean!

  """Create a free plan subscription for a customer"""
  customerCreateFreePlanSubscription(id: String!): Boolean!

  """Toggle whether a customer is automatically withdrawing to credits"""
  customerTogglePayoutsToCredits(customerId: String!, input: customerTogglePayoutsToCreditsInput!): Boolean!

  """Approves a deployment."""
  deploymentApprove(id: String!): Boolean!

  """Cancels a deployment."""
  deploymentCancel(id: String!): Boolean!

  """Invoke a deployment instance execution."""
  deploymentInstanceExecutionCreate(input: DeploymentInstanceExecutionCreateInput!): Boolean!

  """Redeploys a deployment."""
  deploymentRedeploy(id: String!, usePreviousImageTag: Boolean): Deployment!

  """Removes a deployment."""
  deploymentRemove(id: String!): Boolean!

  """Restarts a deployment."""
  deploymentRestart(id: String!): Boolean!

  """Rolls back to a deployment."""
  deploymentRollback(id: String!): Boolean!

  """Stops a deployment."""
  deploymentStop(id: String!): Boolean!

  """Creates a deployment trigger."""
  deploymentTriggerCreate(input: DeploymentTriggerCreateInput!): DeploymentTrigger!

  """Deletes a deployment trigger."""
  deploymentTriggerDelete(id: String!): Boolean!

  """Updates a deployment trigger."""
  deploymentTriggerUpdate(id: String!, input: DeploymentTriggerUpdateInput!): DeploymentTrigger!

  """Create services and volumes from docker compose"""
  dockerComposeImport(environmentId: String!, projectId: String!, skipStagingPatch: Boolean, yaml: String!): DockerComposeImport!

  """Create a new egress gateway association for a service instance"""
  egressGatewayAssociationCreate(input: EgressGatewayCreateInput!): [EgressGateway!]!

  """Clear all egress gateway associations for a service instance"""
  egressGatewayAssociationsClear(input: EgressGatewayServiceTargetInput!): Boolean!

  """
  Change the User's account email if there is a valid change email request.
  """
  emailChangeConfirm(nonce: String!): Boolean!

  """Initiate an email change request for a user"""
  emailChangeInitiate(newEmail: String!): Boolean!

  """Creates a new environment."""
  environmentCreate(input: EnvironmentCreateInput!): Environment!

  """Deletes an environment."""
  environmentDelete(id: String!): Boolean!

  """Commit the provided patch to the environment."""
  environmentPatchCommit(commitMessage: String, environmentId: String!, patch: EnvironmentConfig): String!

  """Renames an environment."""
  environmentRename(id: String!, input: EnvironmentRenameInput!): Environment!

  """Deploys all connected triggers for an environment."""
  environmentTriggersDeploy(input: EnvironmentTriggersDeployInput!): Boolean!

  """Agree to the fair use policy for the currently authenticated user"""
  fairUseAgree(agree: Boolean!): Boolean!

  """Add a feature flag for a user"""
  featureFlagAdd(input: FeatureFlagToggleInput!): Boolean!

  """Remove a feature flag for a user"""
  featureFlagRemove(input: FeatureFlagToggleInput!): Boolean!

  """Deploys a GitHub repo"""
  githubRepoDeploy(input: GitHubRepoDeployInput!): String!

  """Updates a GitHub repo through the linked template"""
  githubRepoUpdate(input: GitHubRepoUpdateInput!): Boolean!

  """
  Import variables from a Heroku app into a Railway service. Returns the number of variables imports
  """
  herokuImportVariables(input: HerokuImportVariablesInput!): Int!

  """Create an integration for a project"""
  integrationCreate(input: IntegrationCreateInput!): Integration!

  """Delete an integration for a project"""
  integrationDelete(id: String!): Boolean!

  """Update an integration for a project"""
  integrationUpdate(id: String!, input: IntegrationUpdateInput!): Integration!

  """Join a project using an invite code"""
  inviteCodeUse(code: String!): Project!

  """Creates a new job application."""
  jobApplicationCreate(input: JobApplicationCreateInput!, resume: Upload!): Boolean!

  """Auth a login session for a user"""
  loginSessionAuth(input: LoginSessionAuthInput!): Boolean!

  """Cancel a login session"""
  loginSessionCancel(code: String!): Boolean!

  """Get a token for a login session if it exists"""
  loginSessionConsume(code: String!): String

  """Start a CLI login session"""
  loginSessionCreate: String!

  """Verify if a login session is valid"""
  loginSessionVerify(code: String!): Boolean!

  """Create an observability dashboard"""
  observabilityDashboardCreate(input: ObservabilityDashboardCreateInput!): Boolean!

  """Reset an observability dashboard to default dashboard items"""
  observabilityDashboardReset(id: String!): Boolean!

  """Update an observability dashboard"""
  observabilityDashboardUpdate(id: String!, input: [ObservabilityDashboardUpdateInput!]!): Boolean!

  """Deletes a Passkey"""
  passkeyDelete(id: String!): Boolean!

  """Creates a new plugin."""
  pluginCreate(input: PluginCreateInput!): Plugin! @deprecated(reason: "Plugins are deprecated on Railway. Use database templates instead.")

  """Deletes a plugin."""
  pluginDelete(environmentId: String, id: String!): Boolean! @deprecated(reason: "Plugins are deprecated")

  """Reset envs and container for a plugin in an environment"""
  pluginReset(id: String!, input: ResetPluginInput!): Boolean! @deprecated(reason: "Plugins are deprecated")

  """Resets the credentials for a plugin in an environment"""
  pluginResetCredentials(id: String!, input: ResetPluginCredentialsInput!): String! @deprecated(reason: "Plugins are deprecated")

  """Restarts a plugin."""
  pluginRestart(id: String!, input: PluginRestartInput!): Plugin! @deprecated(reason: "Plugins are deprecated")

  """Force start a plugin"""
  pluginStart(id: String!, input: PluginRestartInput!): Boolean! @deprecated(reason: "Plugins are deprecated")

  """Updates an existing plugin."""
  pluginUpdate(id: String!, input: PluginUpdateInput!): Plugin! @deprecated(reason: "Plugins are deprecated")

  """
  Create/Updates preferences overrides for a specific resource belonging to a user
  """
  preferenceOverridesCreateUpdate(input: PreferenceOverridesCreateUpdateData!): Boolean!

  """
  Destroy preferences overrides for a specific resource belonging to a user
  """
  preferenceOverridesDestroyForResource(input: PreferenceOverridesDestroyData!): Boolean!

  """Update the email preferences for a user"""
  preferencesUpdate(input: PreferencesUpdateData!): Preferences!

  """Create or get a private network."""
  privateNetworkCreateOrGet(input: PrivateNetworkCreateOrGetInput!): PrivateNetwork!

  """Create or get a private network endpoint."""
  privateNetworkEndpointCreateOrGet(input: PrivateNetworkEndpointCreateOrGetInput!): PrivateNetworkEndpoint!

  """Delete a private network endpoint."""
  privateNetworkEndpointDelete(id: String!): Boolean!

  """Rename a private network endpoint."""
  privateNetworkEndpointRename(dnsName: String!, id: String!, privateNetworkId: String!): Boolean!

  """Delete all private networks for an environment."""
  privateNetworksForEnvironmentDelete(environmentId: String!): Boolean!

  """Claims a project."""
  projectClaim(id: String!, workspaceId: String!): Project!

  """Creates a new project."""
  projectCreate(input: ProjectCreateInput!): Project!

  """Deletes a project."""
  projectDelete(id: String!): Boolean!

  """Accept a project invitation using the invite code"""
  projectInvitationAccept(code: String!): ProjectPermission!

  """Create an invitation for a project"""
  projectInvitationCreate(id: String!, input: ProjectInvitee!): ProjectInvitation!

  """Delete an invitation for a project"""
  projectInvitationDelete(id: String!): Boolean!

  """Resend an invitation for a project"""
  projectInvitationResend(id: String!): ProjectInvitation!

  """Invite a user by email to a project"""
  projectInviteUser(id: String!, input: ProjectInviteUserInput!): Boolean!

  """Leave project as currently authenticated user"""
  projectLeave(id: String!): Boolean!

  """Remove user from a project"""
  projectMemberRemove(input: ProjectMemberRemoveInput!): [ProjectMember!]!

  """Change the role for a user within a project"""
  projectMemberUpdate(input: ProjectMemberUpdateInput!): ProjectMember!

  """Deletes a project with a 48 hour grace period."""
  projectScheduleDelete(id: String!): Boolean!

  """Cancel scheduled deletion of a project"""
  projectScheduleDeleteCancel(id: String!): Boolean!

  """
  Force delete a scheduled deletion of a project (skips the grace period)
  """
  projectScheduleDeleteForce(id: String!): Boolean!

  """Create a token for a project that has access to a specific environment"""
  projectTokenCreate(input: ProjectTokenCreateInput!): String!

  """Delete a project token"""
  projectTokenDelete(id: String!): Boolean!

  """Transfer a project to a workspace"""
  projectTransfer(input: ProjectTransferInput!, projectId: String!): Boolean!

  """Confirm the transfer of project ownership"""
  projectTransferConfirm(input: ProjectTransferConfirmInput!): Boolean!

  """Initiate the transfer of project ownership"""
  projectTransferInitiate(input: ProjectTransferInitiateInput!): Boolean!

  """Transfer a project to a team"""
  projectTransferToTeam(id: String!, input: ProjectTransferToTeamInput!): Boolean! @deprecated(reason: "Use projectTransfer instead")

  """Updates a project."""
  projectUpdate(id: String!, input: ProjectUpdateInput!): Project!

  """Deletes a ProviderAuth."""
  providerAuthRemove(id: String!): Boolean!

  """Generates a new set of recovery codes for the authenticated user."""
  recoveryCodeGenerate: RecoveryCodes!

  """Validates a recovery code."""
  recoveryCodeValidate(input: RecoveryCodeValidateInput!): Boolean!

  """Updates the ReferralInfo for the authenticated user."""
  referralInfoUpdate(input: ReferralInfoUpdateInput!): ReferralInfo!

  """Connect a service to a source"""
  serviceConnect(id: String!, input: ServiceConnectInput!): Service!

  """Creates a new service."""
  serviceCreate(input: ServiceCreateInput!): Service!

  """Deletes a service."""
  serviceDelete(
    """
    [Experimental] Environment ID. If the environment is a forked environment,
    the service will only be deleted in the specified environment, otherwise it
    will deleted in all environments that are not forks of other environments
    """
    environmentId: String
    id: String!
  ): Boolean!

  """Disconnect a service from a repo"""
  serviceDisconnect(id: String!): Service!

  """Creates a new service domain."""
  serviceDomainCreate(input: ServiceDomainCreateInput!): ServiceDomain!

  """Deletes a service domain."""
  serviceDomainDelete(id: String!): Boolean!

  """Updates a service domain."""
  serviceDomainUpdate(input: ServiceDomainUpdateInput!): Boolean!

  """
  Duplicate a service, including its configuration, variables, and volumes.
  """
  serviceDuplicate(environmentId: String!, serviceId: String!): Service! @deprecated(reason: "This API route is used only by the CLI. We plan to remove it in a future version. Please use the UI to duplicate services.")

  """Add a feature flag for a service"""
  serviceFeatureFlagAdd(input: ServiceFeatureFlagToggleInput!): Boolean!

  """Remove a feature flag for a service"""
  serviceFeatureFlagRemove(input: ServiceFeatureFlagToggleInput!): Boolean!

  """Deploy a service instance"""
  serviceInstanceDeploy(commitSha: String, environmentId: String!, latestCommit: Boolean, serviceId: String!): Boolean!

  """Deploy a service instance. Returns a deployment ID"""
  serviceInstanceDeployV2(commitSha: String, environmentId: String!, serviceId: String!): String!

  """Update the resource limits for a service instance"""
  serviceInstanceLimitsUpdate(input: ServiceInstanceLimitsUpdateInput!): Boolean!

  """Redeploy a service instance"""
  serviceInstanceRedeploy(environmentId: String!, serviceId: String!): Boolean!

  """Update a service instance"""
  serviceInstanceUpdate(
    """
    [Experimental] Environment ID. If the environment is a fork, the service
    will only be updated in it. Otherwise it will updated in all environments
    that are not forks of other environments
    """
    environmentId: String
    input: ServiceInstanceUpdateInput!
    serviceId: String!
  ): Boolean!

  """Remove the upstream URL from all service instances for this service"""
  serviceRemoveUpstreamUrl(id: String!): Service!

  """Updates a service."""
  serviceUpdate(id: String!, input: ServiceUpdateInput!): Service!

  """Deletes a session."""
  sessionDelete(id: String!): Boolean!

  """Configure a shared variable."""
  sharedVariableConfigure(input: SharedVariableConfigureInput!): Variable!

  """Creates a new TCP proxy for a service instance."""
  tcpProxyCreate(input: TCPProxyCreateInput!): TCPProxy! @deprecated(reason: "Use staged changes and apply them. Creating a TCP proxy with this endpoint requires you to redeploy the service for it to be active.")

  """Deletes a TCP proxy by id"""
  tcpProxyDelete(id: String!): Boolean!

  """Duplicates an existing template"""
  templateClone(input: TemplateCloneInput!): Template!

  """Deletes a template."""
  templateDelete(id: String!, input: TemplateDeleteInput!): Boolean!

  """Deploys a template."""
  templateDeploy(input: TemplateDeployInput!): TemplateDeployPayload! @deprecated(reason: "Deprecated in favor of templateDeployV2")

  """Deploys a template using the serialized template config"""
  templateDeployV2(input: TemplateDeployV2Input!): TemplateDeployPayload!

  """Generate a template for a project"""
  templateGenerate(input: TemplateGenerateInput!): Template!

  """Publishes a template."""
  templatePublish(id: String!, input: TemplatePublishInput!): Template!

  """
  Ejects a service from the template and creates a new repo in the provided org.
  """
  templateServiceSourceEject(input: TemplateServiceSourceEjectInput!): Boolean!

  """Unpublishes a template."""
  templateUnpublish(id: String!): Boolean!

  """Create a new trusted domain for this workspace"""
  trustedDomainCreate(input: WorkspaceTrustedDomainCreateInput!): Boolean!

  """Delete a trusted domain"""
  trustedDomainDelete(id: String!): Boolean!

  """Setup 2FA authorization for authenticated user."""
  twoFactorInfoCreate(input: TwoFactorInfoCreateInput!): RecoveryCodes!

  """Deletes the TwoFactorInfo for the authenticated user."""
  twoFactorInfoDelete: Boolean!

  """Generates the 2FA app secret for the authenticated user."""
  twoFactorInfoSecret: TwoFactorInfoSecret!

  """Validates the token for a 2FA action or for a login request."""
  twoFactorInfoValidate(input: TwoFactorInfoValidateInput!): Boolean!

  """Generate a Slack channel for a workspace"""
  upsertSlackChannel(workspaceId: String!): Boolean!

  """Remove the usage limit for a customer"""
  usageLimitRemove(input: UsageLimitRemoveInput!): Boolean!

  """Set the usage limit for a customer"""
  usageLimitSet(input: UsageLimitSetInput!): Boolean!

  """Unsubscribe from the Beta program."""
  userBetaLeave: Boolean!

  """Delete the currently authenticated user"""
  userDelete: Boolean!

  """Disconnect your Railway account from Discord."""
  userDiscordDisconnect: Boolean!

  """Remove a flag on the user."""
  userFlagsRemove(input: UserFlagsRemoveInput!): Boolean!

  """Set flags on the authenticated user."""
  userFlagsSet(input: UserFlagsSetInput!): Boolean!

  """Updates the profile for the authenticated user"""
  userProfileUpdate(input: UserProfileUpdateInput!): Boolean!

  """Update date of TermsAgreedOn"""
  userTermsUpdate: User

  """Upserts a collection of variables."""
  variableCollectionUpsert(input: VariableCollectionUpsertInput!): Boolean!

  """Deletes a variable."""
  variableDelete(input: VariableDeleteInput!): Boolean!

  """Upserts a variable."""
  variableUpsert(input: VariableUpsertInput!): Boolean!

  """Create a persistent volume in a project"""
  volumeCreate(input: VolumeCreateInput!): Volume!

  """Delete a persistent volume in a project"""
  volumeDelete(volumeId: String!): Boolean!

  """Create backup of a volume instance"""
  volumeInstanceBackupCreate(
    """The id of the volume instance to create a backup of"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Deletes volume instance backup"""
  volumeInstanceBackupDelete(
    """The volume instance's backup id"""
    volumeInstanceBackupId: String!

    """The volume instance's id"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Removes backup expiration date"""
  volumeInstanceBackupLock(
    """The id of the backup to lock"""
    volumeInstanceBackupId: String!

    """The id of the volume instance to be restored from"""
    volumeInstanceId: String!
  ): Boolean!

  """Restore a volume instance from a backup"""
  volumeInstanceBackupRestore(
    """The id of the backup to be restored from"""
    volumeInstanceBackupId: String!

    """The id of the volume instance to be restored from"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Manage schedule for backups of a volume instance"""
  volumeInstanceBackupScheduleUpdate(
    """The frequency/retention of the backups"""
    kinds: [VolumeInstanceBackupScheduleKind!]!

    """The id of the volume instance to create a backup of"""
    volumeInstanceId: String!
  ): Boolean!

  """
  Update a volume instance. If no environmentId is provided, all volume instances for the volume will be updated.
  """
  volumeInstanceUpdate(
    """
    The environment of the volume instance to update. If null, all instances for the volume will be updated
    """
    environmentId: String
    input: VolumeInstanceUpdateInput!

    """The id of the volume to update"""
    volumeId: String!
  ): Boolean!

  """Update a persistent volume in a project"""
  volumeUpdate(input: VolumeUpdateInput!, volumeId: String!): Volume!

  """Create a webhook on a project"""
  webhookCreate(input: WebhookCreateInput!): ProjectWebhook!

  """Delete a webhook from a project"""
  webhookDelete(id: String!): Boolean!

  """Update a webhook on a project"""
  webhookUpdate(id: String!, input: WebhookUpdateInput!): ProjectWebhook!

  """Delete a workspace and all data associated with it"""
  workspaceDelete(id: String!): Boolean!

  """Get an invite code for a workspace and role"""
  workspaceInviteCodeCreate(input: WorkspaceInviteCodeCreateInput!, workspaceId: String!): String!

  """Use an invite code to join a workspace"""
  workspaceInviteCodeUse(code: String!): Workspace!

  """Leave a workspace"""
  workspaceLeave(id: String!): Boolean!

  """Changes a user workspace permissions."""
  workspacePermissionChange(input: WorkspacePermissionChangeInput!): Boolean!

  """Update a workspace by id"""
  workspaceUpdate(id: String!, input: WorkspaceUpdateInput!): Boolean!

  """Generate a Slack channel for a workspace"""
  workspaceUpsertSlackChannel(id: String!): Boolean!

  """Invite a user by email to a workspace"""
  workspaceUserInvite(input: WorkspaceUserInviteInput!, workspaceId: String!): Boolean!

  """Remove a user from a workspace"""
  workspaceUserRemove(input: WorkspaceUserRemoveInput!, workspaceId: String!): Boolean!
}

interface Node {
  id: ID!
}

type ObservabilityDashboard implements Node {
  id: ID!
  items: [ObservabilityDashboardItemInstance!]!
}

type ObservabilityDashboardAlert implements Node {
  createdAt: DateTime!
  id: ID!
  resolvedAt: DateTime
  resourceId: String
  resourceType: MonitorAlertResourceType!
  status: MonitorStatus!
}

input ObservabilityDashboardCreateInput {
  environmentId: String!

  """If no items are provided, a default dashboard will be created."""
  items: [ObservabilityDashboardUpdateInput!]
}

type ObservabilityDashboardItem implements Node {
  config: ObservabilityDashboardItemConfig!
  description: String
  id: ID!
  monitors: [ObservabilityDashboardMonitor!]!
  name: String!
  type: ObservabilityDashboardItemType!
}

type ObservabilityDashboardItemConfig {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}

input ObservabilityDashboardItemConfigInput {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}

input ObservabilityDashboardItemCreateInput {
  config: ObservabilityDashboardItemConfigInput!
  description: String
  id: String!
  name: String!
  type: ObservabilityDashboardItemType!
}

type ObservabilityDashboardItemInstance implements Node {
  dashboardItem: ObservabilityDashboardItem!
  displayConfig: DisplayConfig!
  id: ID!
}

enum ObservabilityDashboardItemType {
  PROJECT_USAGE_ITEM
  SERVICE_LOGS_ITEM
  SERVICE_METRICS_ITEM
  VOLUME_METRICS_ITEM
}

type ObservabilityDashboardMonitor implements Node {
  alerts(endDate: DateTime, startDate: DateTime): [ObservabilityDashboardAlert!]!
  config: ObservabilityDashboardMonitorConfig!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

union ObservabilityDashboardMonitorConfig = MonitorThresholdConfig

input ObservabilityDashboardUpdateInput {
  dashboardItem: ObservabilityDashboardItemCreateInput!
  displayConfig: DisplayConfig!
  id: String!
}

input OverrideInput {
  enabled: Boolean!
  name: String!
  resource: String!
  resourceId: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Passkey implements Node {
  aaguid: String
  backedUp: Boolean!
  createdAt: DateTime!
  credentialId: String!
  deviceName: String!
  deviceType: String!
  displayName: String
  id: ID!
  lastUsedAt: DateTime
  lastUsedDevice: String
  transports: [String!]!
  updatedAt: DateTime!
}

type PaymentMethod {
  card: PaymentMethodCard
  id: String!
}

type PaymentMethodCard {
  brand: String!
  country: String
  last4: String!
}

enum Plan {
  FREE
  HOBBY
  PRO
}

type PlanLimitOverride implements Node {
  config: SubscriptionPlanLimit!
  id: ID!
}

enum PlatformFeatureFlag {
  ALLOW_REPLICA_METRICS
  BUCKETS
  DEMO_PERCENTAGE_ROLLOUT
  ENABLE_RAW_SQL_QUERIES
  MONOREPO_SUPPORT
  UPDATED_VM_QUERIES
  USE_GH_WEBHOOKS_FOR_CHANGE_DETECTION
  VM_TIME_RANGE_QUERY
}

type PlatformFeatureFlagStatus {
  flag: PlatformFeatureFlag!
  rolloutPercentage: Int!
  status: Boolean!
  type: PlatformFeatureFlagType!
}

enum PlatformFeatureFlagType {
  BOOLEAN
  PERCENTAGE
}

type PlatformStatus {
  incident: Incident
  isStable: Boolean!
  maintenance: Maintenance
}

type Plugin implements Node {
  containers(after: String, before: String, first: Int, last: Int): PluginContainersConnection!
  createdAt: DateTime!
  deletedAt: DateTime
  deprecatedAt: DateTime
  friendlyName: String!
  id: ID!
  logsEnabled: Boolean!
  migrationDatabaseServiceId: String
  name: PluginType!
  project: Project!
  status: PluginStatus!
  variables(after: String, before: String, first: Int, last: Int): PluginVariablesConnection!
}

type PluginContainersConnection {
  edges: [PluginContainersConnectionEdge!]!
  pageInfo: PageInfo!
}

type PluginContainersConnectionEdge {
  cursor: String!
  node: Container!
}

input PluginCreateInput {
  environmentId: String
  friendlyName: String
  name: String!
  projectId: String!
}

input PluginRestartInput {
  environmentId: String
}

enum PluginStatus {
  DEPRECATED
  LOCKED
  REMOVED
  RUNNING
  STOPPED
}

enum PluginType {
  mongodb
  mysql
  postgresql
  redis
}

input PluginUpdateInput {
  friendlyName: String!
}

type PluginVariablesConnection {
  edges: [PluginVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}

type PluginVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}

type PreferenceOverride implements Node {
  enabled: Boolean!
  id: ID!
  name: String!
  resource: String!
  resourceId: String!
}

input PreferenceOverridesCreateUpdateData {
  overrides: [OverrideInput!]!
}

input PreferenceOverridesDestroyData {
  resource: String!
  resourceId: String!
}

type Preferences implements Node {
  buildFailedEmail: Boolean!
  changelogEmail: Boolean!
  communityEmail: Boolean!
  deployCrashedEmail: Boolean!
  ephemeralEnvironmentEmail: Boolean!
  id: ID!
  marketingEmail: Boolean!
  preferenceOverrides: [PreferenceOverride!]
  subprocessorUpdatesEmail: Boolean!
  usageEmail: Boolean!
}

input PreferencesUpdateData {
  buildFailedEmail: Boolean
  changelogEmail: Boolean
  communityEmail: Boolean
  deployCrashedEmail: Boolean
  ephemeralEnvironmentEmail: Boolean
  marketingEmail: Boolean
  subprocessorUpdatesEmail: Boolean
  token: String
  usageEmail: Boolean
}

type PrivateNetwork {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  environmentId: String!
  name: String!
  networkId: BigInt!
  projectId: String!
  publicId: String!
  tags: [String!]!
}

input PrivateNetworkCreateOrGetInput {
  environmentId: String!
  name: String!
  projectId: String!
  tags: [String!]!
}

type PrivateNetworkEndpoint {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  privateIps: [String!]!
  publicId: String!
  serviceInstanceId: String!
  tags: [String!]!
}

input PrivateNetworkEndpointCreateOrGetInput {
  environmentId: String!
  privateNetworkId: String!
  serviceId: String!
  serviceName: String!
  tags: [String!]!
}

type Project implements Node {
  baseEnvironment: Environment
  baseEnvironmentId: String
  botPrEnvironments: Boolean!
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): ProjectDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): ProjectDeploymentsConnection!
  description: String
  environments(after: String, before: String, first: Int, last: Int): ProjectEnvironmentsConnection!
  expiredAt: DateTime
  groups(after: String, before: String, first: Int, last: Int): ProjectGroupsConnection!
  id: ID!
  isPublic: Boolean!
  isTempProject: Boolean!
  members: [ProjectMember!]!
  name: String!
  plugins(after: String, before: String, first: Int, last: Int): ProjectPluginsConnection! @deprecated(reason: "Plugins have been removed")
  prDeploys: Boolean!
  projectPermissions(after: String, before: String, first: Int, last: Int): ProjectProjectPermissionsConnection!
  services(after: String, before: String, first: Int, last: Int): ProjectServicesConnection!
  subscriptionPlanLimit: SubscriptionPlanLimit!
  subscriptionType: SubscriptionPlanType!
  team: Team @deprecated(reason: "Use workspace")
  teamId: String @deprecated(reason: "Use workspaceId")
  updatedAt: DateTime!
  volumes(after: String, before: String, first: Int, last: Int): ProjectVolumesConnection!
  webhooks(after: String, before: String, first: Int, last: Int): ProjectWebhooksConnection!
  workspace: Workspace
  workspaceId: String
}

input ProjectCreateInput {
  defaultEnvironmentName: String
  description: String
  isMonorepo: Boolean
  isPublic: Boolean
  name: String
  prDeploys: Boolean
  repo: ProjectCreateRepo
  runtime: PublicRuntime
  workspaceId: String
}

input ProjectCreateRepo {
  branch: String!
  fullRepoName: String!
}

type ProjectDeploymentsConnection {
  edges: [ProjectDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type ProjectDeploymentTriggersConnection {
  edges: [ProjectDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type ProjectEnvironmentsConnection {
  edges: [ProjectEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}

type ProjectGroupsConnection {
  edges: [ProjectGroupsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectGroupsConnectionEdge {
  cursor: String!
}

type ProjectInvitation {
  email: String!
  expiresAt: DateTime!
  id: ID!
  inviter: ProjectInvitationInviter
  isExpired: Boolean!
  project: PublicProjectInformation!
}

type ProjectInvitationInviter {
  email: String!
  name: String
}

input ProjectInvitee {
  email: String!
  role: ProjectRole!
}

input ProjectInviteUserInput {
  email: String!
  link: String!
}

type ProjectMember {
  avatar: String
  email: String!
  id: String!
  name: String
  role: ProjectRole!
}

input ProjectMemberRemoveInput {
  projectId: String!
  userId: String!
}

input ProjectMemberUpdateInput {
  projectId: String!
  role: ProjectRole!
  userId: String!
}

type ProjectPermission implements Node {
  id: ID!
  projectId: String!
  role: ProjectRole!
  userId: String!
}

type ProjectPluginsConnection {
  edges: [ProjectPluginsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectPluginsConnectionEdge {
  cursor: String!
  node: Plugin!
}

type ProjectProjectPermissionsConnection {
  edges: [ProjectProjectPermissionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectProjectPermissionsConnectionEdge {
  cursor: String!
  node: ProjectPermission!
}

type ProjectResourceAccess {
  customDomain: AccessRule!
  databaseDeployment: AccessRule!
  deployment: AccessRule!
  environment: AccessRule!
  plugin: AccessRule! @deprecated(reason: "Plugins have been removed")
}

enum ProjectRole {
  ADMIN
  MEMBER
  VIEWER
}

type ProjectServicesConnection {
  edges: [ProjectServicesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectServicesConnectionEdge {
  cursor: String!
  node: Service!
}

type ProjectToken implements Node {
  createdAt: DateTime!
  displayToken: String!
  environment: Environment!
  environmentId: String!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
}

input ProjectTokenCreateInput {
  environmentId: String!
  name: String!
  projectId: String!
}

input ProjectTransferConfirmInput {
  destinationWorkspaceId: String
  ownershipTransferId: String!
  projectId: String!
}

input ProjectTransferInitiateInput {
  memberId: String!
  projectId: String!
}

input ProjectTransferInput {
  workspaceId: String!
}

input ProjectTransferToTeamInput {
  teamId: String!
}

input ProjectUpdateInput {
  baseEnvironmentId: String

  """Enable/disable pull request environments for PRs created by bots"""
  botPrEnvironments: Boolean
  description: String
  isPublic: Boolean
  name: String
  prDeploys: Boolean
}

enum ProjectUsageProperty {
  BACKUP_USAGE
  CPU_USAGE
  CURRENT_USAGE
  DISK_USAGE
  ESTIMATED_USAGE
  MEMORY_USAGE
  NETWORK_USAGE
}

type ProjectVolumesConnection {
  edges: [ProjectVolumesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectVolumesConnectionEdge {
  cursor: String!
  node: Volume!
}

type ProjectWebhook implements Node {
  filters: [String!]
  id: ID!
  lastStatus: Int
  projectId: String!
  url: String!
}

type ProjectWebhooksConnection {
  edges: [ProjectWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}

type ProviderAuth implements Node {
  email: String!
  id: ID!
  isAuthEnabled: Boolean!
  metadata: JSON!
  provider: String!
  userId: String!
}

type PublicProjectInformation {
  id: ID!
  name: String!
}

union PublicProjectInvitation = InviteCode | ProjectInvitation

enum PublicRuntime {
  LEGACY
  UNSPECIFIED
  V2
}

type PublicStats {
  totalDeploymentsLastMonth: Int!
  totalLogsLastMonth: BigInt!
  totalProjects: Int!
  totalRequestsLastMonth: BigInt!
  totalServices: Int!
  totalUsers: Int!
}

type Query {
  """Get all volume instances for a given volume"""
  adminVolumeInstancesForVolume(volumeId: String!): [VolumeInstance!]!

  """Returns the platform feature flags enabled for the current user"""
  allPlatformFeatureFlags: [PlatformFeatureFlagStatus!]!

  """Gets all API tokens for the authenticated user."""
  apiTokens(after: String, before: String, first: Int, last: Int): QueryApiTokensConnection!

  """Fetch logs for a build"""
  buildLogs(
    deploymentId: String!
    endDate: DateTime

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: DateTime
  ): [Log!]!

  """Gets the image URL for a Notion image block"""
  changelogBlockImage(id: String!): String!

  """Fetch details for a custom domain"""
  customDomain(id: String!, projectId: String!): CustomDomain!

  """Checks if a custom domain is available."""
  customDomainAvailable(domain: String!): DomainAvailable!

  """Find a single deployment"""
  deployment(id: String!): Deployment!

  """Get the deployment events for a deployment"""
  deploymentEvents(after: String, before: String, first: Int, id: String!, last: Int): QueryDeploymentEventsConnection!

  """Get the deployment instance executions for a deployment."""
  deploymentInstanceExecutions(after: String, before: String, first: Int, input: DeploymentInstanceExecutionListInput!, last: Int): QueryDeploymentInstanceExecutionsConnection!

  """Fetch logs for a deployment"""
  deploymentLogs(
    deploymentId: String!
    endDate: DateTime

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: DateTime
  ): [Log!]!

  """Find a single DeploymentSnapshot"""
  deploymentSnapshot(deploymentId: String!): DeploymentSnapshot

  """All deployment triggers."""
  deploymentTriggers(after: String, before: String, environmentId: String!, first: Int, last: Int, projectId: String!, serviceId: String!): QueryDeploymentTriggersConnection!

  """Get all deployments"""
  deployments(after: String, before: String, first: Int, input: DeploymentListInput!, last: Int): QueryDeploymentsConnection!

  """Domain with status"""
  domainStatus(id: String!, projectId: String!): DomainWithStatus! @deprecated(reason: "Use the `status` field within the `domain` query instead")

  """All domains for a service instance"""
  domains(environmentId: String!, projectId: String!, serviceId: String!): AllDomains!

  """All egress gateways assigned to a service instance"""
  egressGateways(environmentId: String!, serviceId: String!): [EgressGateway!]!

  """Find a single environment"""
  environment(id: String!, projectId: String): Environment!

  """
  Fetch logs for a project environment. Build logs are excluded unless a snapshot ID is explicitly provided in the filter
  """
  environmentLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    environmentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [Log!]!

  """Get a single environment patch by ID"""
  environmentPatch(id: String!): EnvironmentPatch!

  """Get the patches for an environment"""
  environmentPatches(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryEnvironmentPatchesConnection!

  """Get the latest staged commit for a single environment."""
  environmentStagedChanges(environmentId: String!): EnvironmentPatch!

  """Gets all environments for a project."""
  environments(after: String, before: String, first: Int, isEphemeral: Boolean, last: Int, projectId: String!): QueryEnvironmentsConnection!

  """
  Get the estimated total cost of the project at the end of the current billing
  cycle. If no `startDate` is provided, the usage for the current billing period
  of the project owner is returned.
  """
  estimatedUsage(
    """Whether to include deleted projects in estimations."""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    projectId: String
    workspaceId: String
  ): [EstimatedUsage!]!

  """Gets the events for a project."""
  events(after: String, before: String, environmentId: String, filter: EventFilterInput, first: Int, last: Int, projectId: String!): QueryEventsConnection!

  """
  Get the workspaces the user doesn't belong to, but needs access (like when invited to a project)
  """
  externalWorkspaces(projectId: String): [ExternalWorkspace!]!

  """Get information about a specific function runtime"""
  functionRuntime(name: FunctionRuntimeName!): FunctionRuntime!

  """List available function runtimes"""
  functionRuntimes: [FunctionRuntime!]!

  """Checks if user has access to GitHub repository"""
  gitHubRepoAccessAvailable(fullRepoName: String!): GitHubAccess!

  """Check if a repo name is available"""
  githubIsRepoNameAvailable(fullRepoName: String!): Boolean!

  """Checks if user has access to GitHub repository"""
  githubRepo(fullRepoName: String!): GitHubRepoWithoutInstallation!

  """
  Get branches for a GitHub repo that the authenticated user has access to
  """
  githubRepoBranches(owner: String!, repo: String!): [GitHubBranch!]!

  """Get a list of repos for a user that Railway has access to"""
  githubRepos: [GitHubRepo!]!

  """Get a list of scopes the user has installed the installation to"""
  githubWritableScopes: [String!]!

  """Get the Herokus apps for the current user"""
  herokuApps: [HerokuApp!]!

  """Fetch HTTP logs for a deployment"""
  httpLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    deploymentId: String!
    endDate: String

    """Filter logs using a query syntax"""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: String
  ): [HttpLog!]!

  """Get an integration auth by provider providerId"""
  integrationAuth(provider: String!, providerId: String!): IntegrationAuth!

  """Get all integration auths for a user"""
  integrationAuths(after: String, before: String, first: Int, last: Int): QueryIntegrationAuthsConnection!

  """Get all integrations for a project"""
  integrations(after: String, before: String, first: Int, last: Int, projectId: String!): QueryIntegrationsConnection!

  """Get an invite code by the code"""
  inviteCode(code: String!): InviteCode!

  """Gets the authenticated user."""
  me: User!

  """Get metrics for a project, environment, and service"""
  metrics(
    """
    The averaging window when computing CPU usage. By default, it is the same as the `sampleRateSeconds`.
    """
    averagingWindowSeconds: Int

    """
    The end of the period to get metrics for. If not provided, the current datetime is used.
    """
    endDate: DateTime
    environmentId: String

    """
    What to group the aggregated usage by. By default, it is grouped over the entire project.
    """
    groupBy: [MetricTag!]

    """Whether or not to include deleted projects in the results"""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    projectId: String

    """
    The frequency of data points in the response. If the `sampleRateSeconds` is
    60, then the response will contain one data point per minute.
    """
    sampleRateSeconds: Int
    serviceId: String

    """The start of the period to get metrics for."""
    startDate: DateTime!
    volumeId: String
    volumeInstanceExternalId: String
    workspaceId: String
  ): [MetricsResult!]!
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!

  """Get all observability dashboards for an environment"""
  observabilityDashboards(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryObservabilityDashboardsConnection!

  """Gets all passkeys for the authenticated user"""
  passkeys(after: String, before: String, first: Int, last: Int): QueryPasskeysConnection!

  """Get the current status of the platform"""
  platformStatus: PlatformStatus!

  """Get a plugin by ID."""
  plugin(id: String!): Plugin! @deprecated(reason: "Plugins are deprecated")

  """Fetch logs for a plugin"""
  pluginLogs(
    endDate: DateTime
    environmentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    pluginId: String!
    startDate: DateTime
  ): [Log!]! @deprecated(reason: "Plugins are deprecated")

  """Get the email preferences for a user"""
  preferences(token: String): Preferences!

  """Get a private network endpoint for a service instance."""
  privateNetworkEndpoint(environmentId: String!, privateNetworkId: String!, serviceId: String!): PrivateNetworkEndpoint

  """Check if an endpoint name is available."""
  privateNetworkEndpointNameAvailable(environmentId: String!, prefix: String!, privateNetworkId: String!): Boolean!

  """List private networks for an environment."""
  privateNetworks(environmentId: String!): [PrivateNetwork!]!

  """Get a project by ID"""
  project(id: String!): Project!

  """Get a project invitation by code"""
  projectInvitation(code: String!): PublicProjectInvitation!

  """Get invitations for a project"""
  projectInvitations(id: String!): [ProjectInvitation!]!

  """Get an invite code for a project for a specifc role"""
  projectInviteCode(projectId: String!, role: ProjectRole!): InviteCode!

  """Gets users who belong to a project along with their role"""
  projectMembers(projectId: String!): [ProjectMember!]!

  """Get resource access rules for project-specific actions"""
  projectResourceAccess(projectId: String!): ProjectResourceAccess!

  """Get a single project token by the value in the header"""
  projectToken: ProjectToken!

  """Get all project tokens for a project"""
  projectTokens(after: String, before: String, first: Int, last: Int, projectId: String!): QueryProjectTokensConnection!

  """Gets all projects for a user or workspace."""
  projects(after: String, before: String, first: Int, includeDeleted: Boolean, last: Int, userId: String, workspaceId: String): QueryProjectsConnection!

  """Get public Railway stats."""
  publicStats: PublicStats!

  """Gets the ReferralInfo for the authenticated user."""
  referralInfo(workspaceId: String!): ReferralInfo!

  """List available regions"""
  regions(projectId: String): [Region!]!

  """Get resource access for the current user or workspace"""
  resourceAccess(explicitResourceOwner: ExplicitOwnerInput!): ResourceAccess!

  """Get a service by ID"""
  service(id: String!): Service!

  """Checks if a service domain is available"""
  serviceDomainAvailable(domain: String!): DomainAvailable!

  """Get a service instance belonging to a service and environment"""
  serviceInstance(environmentId: String!, serviceId: String!): ServiceInstance!

  """Check if the upstream repo for a service has an update available"""
  serviceInstanceIsUpdatable(environmentId: String!, serviceId: String!): Boolean!

  """
  Get the service instance resource limit overrides (null if no overrides set)
  """
  serviceInstanceLimitOverride(environmentId: String!, serviceId: String!): ServiceInstanceLimit

  """
  Get the merged resource limits for a service instance (includes plan defaults)
  """
  serviceInstanceLimits(environmentId: String!, serviceId: String!): ServiceInstanceLimit!

  """Gets all sessions for authenticated user."""
  sessions(after: String, before: String, first: Int, last: Int): QuerySessionsConnection!

  """All TCP proxies for a service instance"""
  tcpProxies(environmentId: String!, serviceId: String!): [TCPProxy!]!

  """Find a team by ID"""
  team(id: String!): Team! @deprecated(reason: "Teams are now workspaces. Use the workspace query instead.")

  """Get all templates for a team."""
  teamTemplates(after: String, before: String, first: Int, last: Int, teamId: String!): QueryTeamTemplatesConnection! @deprecated(reason: "Use templates instead - teams are now workspaces")

  """Get a template by code or ID or GitHub owner and repo."""
  template(code: String, id: String, owner: String, repo: String): Template!

  """Get the source template for a project."""
  templateSourceForProject(projectId: String!): Template

  """Get all published templates."""
  templates(
    after: String
    before: String
    first: Int
    last: Int

    """If set to true, only recommended templates will be returned."""
    recommended: Boolean

    """If set to true, only verified templates will be returned."""
    verified: Boolean
  ): QueryTemplatesConnection!

  """Count all published templates."""
  templatesCount: Int!

  """Get all trusted domains for a workspace"""
  trustedDomains(after: String, before: String, first: Int, last: Int, workspaceId: String!): QueryTrustedDomainsConnection!

  """Gets the TwoFactorInfo for the authenticated user."""
  twoFactorInfo: TwoFactorInfo!

  """
  Get the usage for a single project or all projects for a user/workspace. If no
  `projectId` or `workspaceId` is provided, the usage for the current user is
  returned. If no `startDate` is provided, the usage for the current billing
  period of the project owner is returned.
  """
  usage(
    endDate: DateTime

    """
    What to group the aggregated usage by. By default, it is grouped over the entire project.
    """
    groupBy: [MetricTag!]

    """Whether to include deleted projects in the usage."""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    projectId: String
    startDate: DateTime
    workspaceId: String
  ): [AggregatedUsage!]!

  """Get the total kickback earnings for a user."""
  userKickbackEarnings(userId: String!): UserKickbackEarnings! @deprecated(reason: "This field is deprecated and will be removed in future versions.")

  """Get the public profile for a user"""
  userProfile(username: String!): UserProfileResponse!

  """Get all templates for the current user."""
  userTemplates(after: String, before: String, first: Int, last: Int): QueryUserTemplatesConnection! @deprecated(reason: "Users don't have personal templates anymore, they belong to their team now")

  """
  All variables by pluginId or serviceId. If neither are provided, all shared variables are returned.
  """
  variables(
    environmentId: String!
    projectId: String!

    """Provide a serviceId to get all variables for a specific service."""
    serviceId: String
    unrendered: Boolean
  ): EnvironmentVariables!

  """All rendered variables that are required for a service deployment."""
  variablesForServiceDeployment(environmentId: String!, projectId: String!, serviceId: String!): EnvironmentVariables!

  """Get information about the user's Vercel accounts"""
  vercelInfo: VercelInfo!

  """Get a single volume instance by id"""
  volumeInstance(id: String!): VolumeInstance!

  """List backups of a volume instance"""
  volumeInstanceBackupList(
    """The id of the volume instance to list the backups of"""
    volumeInstanceId: String!
  ): [VolumeInstanceBackup!]!

  """List backups schedules of a volume instance"""
  volumeInstanceBackupScheduleList(
    """The id of the volume instance to list the schedules of"""
    volumeInstanceId: String!
  ): [VolumeInstanceBackupSchedule!]!

  """Get all webhooks for a project"""
  webhooks(after: String, before: String, first: Int, last: Int, projectId: String!): QueryWebhooksConnection!

  """Gets the status of a workflow"""
  workflowStatus(workflowId: String!): WorkflowResult!

  """Get the workspace"""
  workspace(workspaceId: String!): Workspace!

  """Find a workspace by invite code"""
  workspaceByCode(code: String!): Workspace!

  """Get all templates for a workspace."""
  workspaceTemplates(after: String, before: String, first: Int, last: Int, workspaceId: String!): QueryWorkspaceTemplatesConnection!
}

type QueryApiTokensConnection {
  edges: [QueryApiTokensConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryApiTokensConnectionEdge {
  cursor: String!
  node: ApiToken!
}

type QueryDeploymentEventsConnection {
  edges: [QueryDeploymentEventsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentEventsConnectionEdge {
  cursor: String!
  node: DeploymentEvent!
}

type QueryDeploymentInstanceExecutionsConnection {
  edges: [QueryDeploymentInstanceExecutionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentInstanceExecutionsConnectionEdge {
  cursor: String!
  node: DeploymentInstanceExecution!
}

type QueryDeploymentsConnection {
  edges: [QueryDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type QueryDeploymentTriggersConnection {
  edges: [QueryDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type QueryEnvironmentPatchesConnection {
  edges: [QueryEnvironmentPatchesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEnvironmentPatchesConnectionEdge {
  cursor: String!
  node: EnvironmentPatch!
}

type QueryEnvironmentsConnection {
  edges: [QueryEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}

type QueryEventsConnection {
  edges: [QueryEventsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEventsConnectionEdge {
  cursor: String!
  node: Event!
}

type QueryIntegrationAuthsConnection {
  edges: [QueryIntegrationAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryIntegrationAuthsConnectionEdge {
  cursor: String!
  node: IntegrationAuth!
}

type QueryIntegrationsConnection {
  edges: [QueryIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}

type QueryObservabilityDashboardsConnection {
  edges: [QueryObservabilityDashboardsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryObservabilityDashboardsConnectionEdge {
  cursor: String!
  node: ObservabilityDashboard!
}

type QueryPasskeysConnection {
  edges: [QueryPasskeysConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryPasskeysConnectionEdge {
  cursor: String!
  node: Passkey!
}

type QueryProjectsConnection {
  edges: [QueryProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

type QueryProjectTokensConnection {
  edges: [QueryProjectTokensConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryProjectTokensConnectionEdge {
  cursor: String!
  node: ProjectToken!
}

type QuerySessionsConnection {
  edges: [QuerySessionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QuerySessionsConnectionEdge {
  cursor: String!
  node: Session!
}

type QueryTeamTemplatesConnection {
  edges: [QueryTeamTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTeamTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryTemplatesConnection {
  edges: [QueryTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryTrustedDomainsConnection {
  edges: [QueryTrustedDomainsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTrustedDomainsConnectionEdge {
  cursor: String!
  node: TrustedDomain!
}

type QueryUserTemplatesConnection {
  edges: [QueryUserTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryUserTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryWebhooksConnection {
  edges: [QueryWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}

type QueryWorkspaceTemplatesConnection {
  edges: [QueryWorkspaceTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryWorkspaceTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

scalar RailpackInfo

type RecoveryCodes {
  recoveryCodes: [String!]!
}

input RecoveryCodeValidateInput {
  code: String!
  twoFactorLinkingKey: String
}

type ReferralInfo implements Node {
  code: String!
  id: ID!
  referralStats: ReferralStats!
  status: String!
}

input ReferralInfoUpdateInput {
  code: String!
  workspaceId: String!
}

type ReferralStats {
  credited: Int!
  pending: Int!
}

enum ReferralStatus {
  REFEREE_CREDITED
  REFERRER_CREDITED
  REGISTERED
}

type ReferralUser {
  code: String!
  id: String!
  status: ReferralStatus!
}

type RefundRequest implements Node {
  amount: Int!
  decision: RefundRequestDecisionEnum
  id: ID!
  invoiceId: String!
  plainThreadId: String
  reason: String!
  userId: String
  workspace: Workspace!
}

"""Possible decisions for a RefundRequest"""
enum RefundRequestDecisionEnum {
  AUTO_REFUNDED
  AUTO_REJECTED
  MANUALLY_REFUNDED
}

type Region {
  """Region country"""
  country: String!
  deploymentConstraints: RegionDeploymentConstraints
  location: String!
  name: String!

  """Region is on Railway Metal"""
  railwayMetal: Boolean
  region: String
  workspaceId: String
}

type RegionDeploymentConstraints {
  """Admin only region"""
  adminOnly: Boolean

  """Deprecation information for the region"""
  deprecationInfo: RegionDeprecationInfo
  runtimeExclusivity: [String!]

  """Staging only region"""
  stagingOnly: Boolean
}

type RegionDeprecationInfo {
  """Specifies if the region is deprecated"""
  isDeprecated: Boolean!

  """Replacement region for the deprecated region"""
  replacementRegion: String!
}

enum RegistrationStatus {
  ONBOARDED
  REGISTERED
  WAITLISTED
}

"""
Private Docker registry credentials. Only available for Pro plan deployments.
"""
input RegistryCredentialsInput {
  password: String!
  username: String!
}

type ReissuedInvoice implements Node {
  id: ID!
  originalInvoiceId: String!
  reissuedInvoiceId: String
  workspace: Workspace!
  workspaceId: String!
}

enum ReplicateVolumeInstanceSnapshotStatus {
  COMPLETED
  FAILED
  INITIATED
  TRANSFERRING
  UNRECOGNIZED
}

"""The status of a volume instance replication"""
enum ReplicateVolumeInstanceStatus {
  COMPLETED
  ERROR
  QUEUED
  TRANSFERRING_OFFLINE
  TRANSFERRING_ONLINE
}

input ResetPluginCredentialsInput {
  environmentId: String!
}

input ResetPluginInput {
  environmentId: String!
}

type ResourceAccess {
  deployment: AccessRule!
  project: AccessRule!
}

enum ResourceOwnerType {
  WORKSPACE
}

enum RestartPolicyType {
  ALWAYS
  NEVER
  ON_FAILURE
}

scalar SerializedTemplateConfig

type Service implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deployments(after: String, before: String, first: Int, last: Int): ServiceDeploymentsConnection!
  featureFlags: [ActiveServiceFeatureFlag!]!
  icon: String
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  repoTriggers(after: String, before: String, first: Int, last: Int): ServiceRepoTriggersConnection!
  serviceInstances(after: String, before: String, first: Int, last: Int): ServiceServiceInstancesConnection!
  templateServiceId: String
  templateThreadSlug: String
  updatedAt: DateTime!
}

input ServiceConnectInput {
  """The branch to connect to. e.g. 'main'"""
  branch: String

  """Name of the Dockerhub or GHCR image to connect this service to."""
  image: String

  """The full name of the repo to connect to. e.g. 'railwayapp/starters'"""
  repo: String
}

input ServiceCreateInput {
  branch: String

  """
  Environment ID. If the specified environment is a fork, the service will only
  be created in it. Otherwise it will created in all environments that are not
  forks of other environments
  """
  environmentId: String
  icon: String
  name: String
  projectId: String!
  registryCredentials: RegistryCredentialsInput
  source: ServiceSourceInput
  templateServiceId: String
  variables: EnvironmentVariables
}

type ServiceDeploymentsConnection {
  edges: [ServiceDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type ServiceDomain implements Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  suffix: String
  targetPort: Int
  updatedAt: DateTime
}

input ServiceDomainCreateInput {
  environmentId: String!
  serviceId: String!
  targetPort: Int
}

input ServiceDomainUpdateInput {
  domain: String!
  environmentId: String!
  serviceDomainId: String
  serviceId: String!
  targetPort: Int
}

input ServiceFeatureFlagToggleInput {
  flag: ActiveServiceFeatureFlag!
  serviceId: String!
}

type ServiceInstance implements Node {
  buildCommand: String
  builder: Builder!
  createdAt: DateTime!
  cronSchedule: String
  deletedAt: DateTime
  domains: AllDomains!
  drainingSeconds: Int
  environmentId: String!
  healthcheckPath: String
  healthcheckTimeout: Int
  id: ID!
  isUpdatable: Boolean!
  latestDeployment: Deployment
  nextCronRunAt: DateTime
  nixpacksPlan: JSON
  numReplicas: Int
  overlapSeconds: Int
  preDeployCommand: JSON
  railpackInfo: RailpackInfo
  railwayConfigFile: String
  region: String
  restartPolicyMaxRetries: Int!
  restartPolicyType: RestartPolicyType!
  rootDirectory: String
  serviceId: String!
  serviceName: String!
  sleepApplication: Boolean
  source: ServiceSource
  startCommand: String
  updatedAt: DateTime!
  upstreamUrl: String
  watchPatterns: [String!]!
}

scalar ServiceInstanceLimit

input ServiceInstanceLimitsUpdateInput {
  environmentId: String!

  """Amount of memory in GB to allocate to the service instance"""
  memoryGB: Float
  serviceId: String!

  """Number of vCPUs to allocate to the service instance"""
  vCPUs: Float
}

input ServiceInstanceUpdateInput {
  buildCommand: String
  builder: Builder
  cronSchedule: String
  drainingSeconds: Int
  healthcheckPath: String
  healthcheckTimeout: Int
  multiRegionConfig: JSON
  nixpacksPlan: JSON
  numReplicas: Int
  overlapSeconds: Int
  preDeployCommand: [String!]
  railwayConfigFile: String
  region: String
  registryCredentials: RegistryCredentialsInput
  restartPolicyMaxRetries: Int
  restartPolicyType: RestartPolicyType
  rootDirectory: String
  sleepApplication: Boolean
  source: ServiceSourceInput
  startCommand: String
  watchPatterns: [String!]
}

type ServiceRepoTriggersConnection {
  edges: [ServiceRepoTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceRepoTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type ServiceServiceInstancesConnection {
  edges: [ServiceServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}

type ServiceSource {
  image: String
  repo: String
}

input ServiceSourceInput {
  image: String
  repo: String
}

input ServiceUpdateInput {
  icon: String
  name: String
}

type Session implements Node {
  createdAt: DateTime!
  expiredAt: DateTime!
  id: ID!
  isCurrent: Boolean!
  name: String!
  type: SessionType!
  updatedAt: DateTime!
}

enum SessionType {
  BROWSER
  CLI
  FORUMS
}

input SharedVariableConfigureInput {
  disabledServiceIds: [String!]!
  enabledServiceIds: [String!]!
  environmentId: String!
  name: String!
  projectId: String!
}

type SimilarTemplate {
  code: String!
  createdAt: DateTime!
  creator: TemplateCreator
  deploys: Int!
  description: String
  health: Float
  image: String
  name: String!
  teamId: String @deprecated(reason: "Use workspaceId")
  userId: String
  workspaceId: String
}

type Subscription {
  """Stream logs for a build"""
  buildLogs(
    deploymentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
  ): [Log!]!

  """Subscribe to updates for a specific deployment"""
  deployment(id: String!): Deployment!

  """Subscribe to deployment events for a specific deployment"""
  deploymentEvents(id: String!): DeploymentEvent!

  """Subscribe to deployment instance executions for a specific deployment"""
  deploymentInstanceExecutions(input: DeploymentInstanceExecutionInput!): DeploymentInstanceExecution!

  """Stream logs for a deployment"""
  deploymentLogs(
    deploymentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
  ): [Log!]!

  """Stream logs for a project environment"""
  environmentLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    environmentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [Log!]!

  """Subscribe to updates for the staged patch for a single environment."""
  environmentStagedPatch(environmentId: String!): EnvironmentPatch!

  """Stream HTTP logs for a deployment"""
  httpLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    deploymentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [HttpLog!]!

  """Stream logs for a plugin"""
  pluginLogs(
    environmentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    pluginId: String!
  ): [Log!]! @deprecated(reason: "Plugins are deprecated")

  """Subscribe to migration progress updates for a volume"""
  replicationProgress(volumeInstanceId: String!): VolumeReplicationProgressUpdate!
}

type SubscriptionDiscount {
  couponId: String!
}

type SubscriptionItem {
  itemId: String!
  priceId: String!
  productId: String!
  quantity: BigInt
}

enum SubscriptionModel {
  FREE
  TEAM
  USER
}

scalar SubscriptionPlanLimit

enum SubscriptionPlanType {
  free
  hobby
  pro
  trial
}

enum SubscriptionState {
  ACTIVE
  CANCELLED
  INACTIVE
  PAST_DUE
  UNPAID
}

enum SupportTierOverride {
  BUSINESS_CLASS
  BUSINESS_CLASS_TRIAL
}

type TCPProxy {
  applicationPort: Int!
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  proxyPort: Int!
  serviceId: String!
  updatedAt: DateTime
}

input TCPProxyCreateInput {
  applicationPort: Int!
  environmentId: String!
  serviceId: String!
}

type Team implements Node {
  adoptionHistory: [AdoptionInfo!]! @deprecated(reason: "Use workspace object instead")
  adoptionLevel: Float! @deprecated(reason: "Use workspace object instead")
  apiTokenRateLimit: ApiTokenRateLimit @deprecated(reason: "Use workspace object instead")
  avatar: String @deprecated(reason: "Use workspace object instead")
  createdAt: DateTime! @deprecated(reason: "Use workspace object instead")
  customer: Customer! @deprecated(reason: "Use workspace object instead")
  id: ID! @deprecated(reason: "Use workspace object instead")
  members: [TeamMember!]! @deprecated(reason: "Use workspace object instead")
  name: String! @deprecated(reason: "Use workspace object instead")
  preferredRegion: String @deprecated(reason: "Use workspace object instead")
  projects(after: String, before: String, first: Int, last: Int): TeamProjectsConnection! @deprecated(reason: "Use workspace object instead")
  slackChannelId: String @deprecated(reason: "Use workspace object instead")
  supportTierOverride: SupportTierOverride @deprecated(reason: "Use workspace object instead")
  teamPermissions: [TeamPermission!]! @deprecated(reason: "Use workspace object instead")
  updatedAt: DateTime! @deprecated(reason: "Use workspace object instead")
  workspace: Workspace! @deprecated(reason: "Use workspace object instead")
}

type TeamMember {
  avatar: String
  email: String!

  """Only retrieved if requested by an admin"""
  featureFlags: [ActiveFeatureFlag!]
  id: String!
  name: String
  role: TeamRole!
}

type TeamPermission implements Node {
  createdAt: DateTime!
  id: ID!
  role: TeamRole!
  updatedAt: DateTime!
  userId: String!
  workspaceId: String!
}

type TeamProjectsConnection {
  edges: [TeamProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type TeamProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

enum TeamRole {
  ADMIN
  MEMBER
  VIEWER
}

type Template implements Node {
  activeProjects: Int!
  canvasConfig: CanvasConfig
  category: String
  code: String!
  communityThreadSlug: String
  config: TemplateConfig! @deprecated(reason: "Use serializedConfig instead")
  createdAt: DateTime!
  creator: TemplateCreator
  demoProjectId: String
  description: String
  guides: TemplateGuide
  health: Float
  id: ID!
  image: String
  isApproved: Boolean!
  isV2Template: Boolean!
  isVerified: Boolean!
  languages: [String!]
  metadata: TemplateMetadata! @deprecated(reason: "Deprecated in favor of listing the fields individually.")
  name: String!
  projects: Int!
  readme: String
  recentProjects: Int!
  serializedConfig: SerializedTemplateConfig
  services(after: String, before: String, first: Int, last: Int): TemplateServicesConnection!
  similarTemplates: [SimilarTemplate!]!
  status: TemplateStatus!
  tags: [String!]
  teamId: String @deprecated(reason: "Use workspaceId")
  totalPayout: Float!
  workspaceId: String
}

input TemplateCloneInput {
  code: String!
  workspaceId: String
}

scalar TemplateConfig

type TemplateCreator {
  avatar: String
  hasPublicProfile: Boolean!
  name: String
  username: String
}

input TemplateDeleteInput {
  workspaceId: String
}

input TemplateDeployInput {
  environmentId: String
  projectId: String
  services: [TemplateDeployService!]!
  templateCode: String
  workspaceId: String
}

type TemplateDeployPayload {
  projectId: String!
  workflowId: String
}

input TemplateDeployService {
  commit: String
  hasDomain: Boolean
  healthcheckPath: String
  id: String!
  isPrivate: Boolean
  name: String
  owner: String
  preDeployCommand: [String!]
  rootDirectory: String
  serviceIcon: String
  serviceName: String!
  startCommand: String
  tcpProxyApplicationPort: Int
  template: String!
  variables: EnvironmentVariables
  volumes: [TemplateVolume!]
}

input TemplateDeployV2Input {
  environmentId: String
  projectId: String
  serializedConfig: SerializedTemplateConfig!
  templateId: String!
  workspaceId: String
}

input TemplateGenerateInput {
  environmentId: String
  projectId: String!
}

type TemplateGuide {
  post: String
  video: String
}

scalar TemplateMetadata

input TemplatePublishInput {
  category: String!
  demoProjectId: String
  description: String!
  image: String
  readme: String!
  workspaceId: String
}

type TemplateService implements Node {
  config: TemplateServiceConfig!
  createdAt: DateTime!
  id: ID!
  templateId: String!
  updatedAt: DateTime!
}

scalar TemplateServiceConfig

type TemplateServicesConnection {
  edges: [TemplateServicesConnectionEdge!]!
  pageInfo: PageInfo!
}

type TemplateServicesConnectionEdge {
  cursor: String!
  node: TemplateService!
}

input TemplateServiceSourceEjectInput {
  projectId: String!
  repoName: String!
  repoOwner: String!

  """Provide multiple serviceIds when ejecting services from a monorepo."""
  serviceIds: [String!]!
  upstreamUrl: String!
}

enum TemplateStatus {
  HIDDEN
  PUBLISHED
  UNPUBLISHED
}

scalar TemplateVolume

type TrustedDomain {
  domainName: String!
  id: ID!
  role: String!
  verificationData: TrustedDomainVerificationData!
  verificationType: String!
  workspaceId: String!
}

type TrustedDomainVerificationData {
  domainMatch: Domain
  domainStatus: CustomDomainStatus
}

type TwoFactorInfo {
  hasRecoveryCodes: Boolean!
  isVerified: Boolean!
}

input TwoFactorInfoCreateInput {
  token: String!
}

type TwoFactorInfoSecret {
  secret: String!
  uri: String!
}

input TwoFactorInfoValidateInput {
  token: String!
  twoFactorLinkingKey: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UsageAnomaly implements Node {
  actedOn: DateTime
  action: UsageAnomalyAction
  actorId: String
  flaggedAt: DateTime!
  flaggedFor: UsageAnomalyFlagReason!
  id: ID!
}

"""Possible actions for a UsageAnomaly."""
enum UsageAnomalyAction {
  ALLOWED
  AUTOBANNED
  BANNED
}

"""Possible flag reasons for a UsageAnomaly."""
enum UsageAnomalyFlagReason {
  HIGH_CPU_USAGE
  HIGH_DISK_USAGE
  HIGH_NETWORK_USAGE
}

type UsageLimit implements Node {
  customerId: String!
  hardLimit: Int
  id: ID!
  isOverLimit: Boolean!
  softLimit: Int!
}

input UsageLimitRemoveInput {
  customerId: String!
}

input UsageLimitSetInput {
  customerId: String!
  hardLimitDollars: Int
  softLimitDollars: Int!
}

type User implements Node {
  agreedFairUse: Boolean!
  apiTokenRateLimit: ApiTokenRateLimit
  avatar: String
  banReason: String
  createdAt: DateTime!
  email: String!
  featureFlags: [ActiveFeatureFlag!]!
  flags: [UserFlag!]!
  has2FA: Boolean!
  id: ID!
  isAdmin: Boolean!
  isConductor: Boolean!
  isVerified: Boolean!
  lastLogin: DateTime!
  name: String
  platformFeatureFlags: [ActivePlatformFlag!]!
  profile: UserProfile
  projects(after: String, before: String, first: Int, last: Int): UserProjectsConnection! @deprecated(reason: "This field will not return anything anymore, go through the workspace's projects")
  providerAuths(after: String, before: String, first: Int, last: Int): UserProviderAuthsConnection!
  registrationStatus: RegistrationStatus!
  riskLevel: Float
  termsAgreedOn: DateTime
  username: String
  workspace: Workspace @deprecated(reason: "Use user.workspaces instead, no user are associated to a workspace")

  """Workspaces user is member of"""
  workspaces: [Workspace!]!
}

enum UserFlag {
  BETA
}

input UserFlagsRemoveInput {
  flags: [UserFlag!]!
  userId: String
}

input UserFlagsSetInput {
  flags: [UserFlag!]!
  userId: String
}

type UserGithubRepo implements Node {
  createdAt: DateTime!
  defaultBranch: String!
  description: String
  fullName: String!
  id: ID!
  installationId: String!
  isPrivate: Boolean!
  lastPushedAt: DateTime!
  name: String!
  ownerAvatarUrl: String
  updatedAt: DateTime!
}

type UserKickbackEarnings {
  total_amount: Float!
}

type UserProfile {
  bio: String
  isPublic: Boolean!
  website: String
}

type UserProfileResponse {
  avatar: String
  createdAt: DateTime!
  customerId: String
  id: String!
  isTrialing: Boolean
  name: String
  profile: UserProfile!

  """Gets all public projects for a user."""
  publicProjects(after: String, before: String, first: Int, last: Int): UserProfileResponsePublicProjectsConnection!
  publishedTemplates: [SimilarTemplate!]! @deprecated(reason: "There are no personal templates anymore, they all belong to a workspace")
  state: String
  totalDeploys: Int!
  username: String
}

type UserProfileResponsePublicProjectsConnection {
  edges: [UserProfileResponsePublicProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProfileResponsePublicProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

input UserProfileUpdateInput {
  bio: String
  isPublic: Boolean!
  website: String
}

type UserProjectsConnection {
  edges: [UserProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

type UserProviderAuthsConnection {
  edges: [UserProviderAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProviderAuthsConnectionEdge {
  cursor: String!
  node: ProviderAuth!
}

type Variable implements Node {
  createdAt: DateTime!
  environment: Environment!
  environmentId: String
  id: ID!
  isSealed: Boolean!
  name: String!
  plugin: Plugin!
  pluginId: String @deprecated(reason: "Plugins have been removed")
  references: [String!]!
  service: Service!
  serviceId: String
  updatedAt: DateTime!
}

input VariableCollectionUpsertInput {
  environmentId: String!
  projectId: String!

  """
  When set to true, removes all existing variables before upserting the new collection.
  """
  replace: Boolean = false
  serviceId: String

  """Skip deploys for affected services"""
  skipDeploys: Boolean = false
  variables: EnvironmentVariables!
}

input VariableDeleteInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String
}

input VariableUpsertInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String

  """Skip deploys for affected services"""
  skipDeploys: Boolean = false
  value: String!
}

type VercelAccount {
  id: String!
  integrationAuthId: String!
  isUser: Boolean!
  name: String
  projects: [VercelProject!]!
  slug: String
}

type VercelInfo {
  accounts: [VercelAccount!]!
}

type VercelProject {
  accountId: String!
  id: String!
  name: String!
}

type Volume implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  volumeInstances(after: String, before: String, first: Int, last: Int): VolumeVolumeInstancesConnection!
}

input VolumeCreateInput {
  """
  The environment to deploy the volume instances into. If `null`, the volume
  will not be deployed to any environment. `undefined` will deploy to all environments.
  """
  environmentId: String

  """The path in the container to mount the volume to"""
  mountPath: String!

  """The project to create the volume in"""
  projectId: String!

  """
  The region to create the volume instances in. If not provided, the default region will be used.
  """
  region: String

  """
  The service to attach the volume to. If not provided, the volume will be disconnected.
  """
  serviceId: String
}

type VolumeInstance implements Node {
  createdAt: DateTime!
  currentSizeMB: Float!
  environment: Environment!
  environmentId: String!
  externalId: String
  id: ID!
  mountPath: String!
  region: String
  service: Service!
  serviceId: String
  sizeMB: Int!
  state: VolumeState
  volume: Volume!
  volumeId: String!
}

type VolumeInstanceBackup {
  createdAt: DateTime!
  creatorId: String
  expiresAt: DateTime
  externalId: String!
  id: String!
  name: String
  referencedMB: Int
  scheduleId: String
  usedMB: Int
}

type VolumeInstanceBackupSchedule implements Node {
  createdAt: DateTime!
  cron: String!
  id: ID!
  kind: VolumeInstanceBackupScheduleKind!
  name: String!
  retentionSeconds: Int
}

enum VolumeInstanceBackupScheduleKind {
  DAILY
  MONTHLY
  WEEKLY
}

type VolumeInstanceReplicationProgress {
  bytesTransferred: BigInt!
  percentComplete: Float!
  timestamp: DateTime!
  transferRateMbps: Float
}

input VolumeInstanceUpdateInput {
  """
  The mount path of the volume instance. If not provided, the mount path will not be updated.
  """
  mountPath: String

  """
  The service to attach the volume to. If not provided, the volume will be disconnected.
  """
  serviceId: String

  """
  The state of the volume instance. If not provided, the state will not be updated.
  """
  state: VolumeState
}

type VolumeReplicationProgressUpdate {
  currentSnapshot: VolumeSnapshotReplicationProgressUpdate!
  destExternalId: String!
  destRegion: String
  destStackerId: String
  error: String
  estimatedTimeRemainingMs: BigInt
  history: [VolumeInstanceReplicationProgress!]!
  nbSnapshots: Int!
  offlineBytesTransferred: BigInt!
  offlineTotalBytes: BigInt!
  onlineBytesTransferred: BigInt!
  onlineTotalBytes: BigInt!
  percentComplete: Float!
  snapshotsSizes: [BigInt!]!
  srcExternalId: String!
  srcRegion: String
  srcStackerId: String
  status: ReplicateVolumeInstanceStatus!
  transferRateMbps: Float
}

type VolumeSnapshotReplicationProgressUpdate {
  bytesTransferred: BigInt!
  compressedBytesTransferred: BigInt!
  compressedTransferRateMbps: Float
  elapsedMs: Int!
  error: String
  estimatedTimeRemainingMs: BigInt
  index: Int!
  percentComplete: Float!
  startedAt: DateTime
  status: ReplicateVolumeInstanceSnapshotStatus!
  totalBytes: BigInt!
  transferRateMbps: Float
}

enum VolumeState {
  DELETED
  DELETING
  ERROR
  MIGRATING
  MIGRATION_PENDING
  READY
  RESTORING
  UPDATING
}

input VolumeUpdateInput {
  """The name of the volume"""
  name: String
}

type VolumeVolumeInstancesConnection {
  edges: [VolumeVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type VolumeVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}

input WebhookCreateInput {
  filters: [String!]
  projectId: String!
  url: String!
}

input WebhookUpdateInput {
  filters: [String!]
  url: String!
}

type Withdrawal implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  status: WithdrawalStatusType!
  updatedAt: DateTime!
  withdrawalAccount: WithdrawalAccount!
  withdrawalAccountId: String!
}

type WithdrawalAccount implements Node {
  customerId: String!
  id: ID!
  platform: WithdrawalPlatformTypes!
  platformDetails: String!
  stripeConnectInfo: WithdrawalAccountStripeConnectInfo
}

type WithdrawalAccountStripeConnectInfo {
  bankLast4: String
  cardLast4: String
  hasOnboarded: Boolean!
  needsAttention: Boolean!
}

enum WithdrawalPlatformTypes {
  BMAC
  GITHUB
  PAYPAL
  STRIPE_CONNECT
}

enum WithdrawalStatusType {
  CANCELLED
  COMPLETED
  FAILED
  PENDING
}

type WorkflowId {
  workflowId: String
}

type WorkflowResult {
  error: String
  status: WorkflowStatus!
}

enum WorkflowStatus {
  Complete
  Error
  NotFound
  Running
}

type Workspace implements Node {
  adoptionHistory: [AdoptionInfo!]!
  adoptionLevel: Float!
  allowDeprecatedRegions: Boolean
  apiTokenRateLimit: ApiTokenRateLimit
  avatar: String
  banReason: String
  createdAt: DateTime!
  customer: Customer!
  discordRole: String
  id: ID!
  members: [WorkspaceMember!]!
  name: String!
  plan: Plan!
  preferredRegion: String
  projects(after: String, before: String, first: Int, last: Int): WorkspaceProjectsConnection!
  referredUsers: [ReferralUser!]!
  slackChannelId: String
  subscriptionModel: SubscriptionModel! @deprecated(reason: "Use plan field instead")
  supportTierOverride: SupportTierOverride
  team: Team @deprecated(reason: "Teams are being removed from the system, don't use it")
  updatedAt: DateTime!
}

input WorkspaceInviteCodeCreateInput {
  role: String!
}

type WorkspaceMember {
  avatar: String
  email: String!

  """Only retrieved if requested by an admin"""
  featureFlags: [ActiveFeatureFlag!]
  id: String!
  name: String
  role: TeamRole!
}

input WorkspacePermissionChangeInput {
  role: TeamRole!
  userId: String!
  workspaceId: String!
}

type WorkspaceProjectsConnection {
  edges: [WorkspaceProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

input WorkspaceTrustedDomainCreateInput {
  domainName: String!
  role: String!
  workspaceId: String!
}

input WorkspaceUpdateInput {
  avatar: String
  name: String
  preferredRegion: String
}

input WorkspaceUserInviteInput {
  code: String!
  email: String!
}

input WorkspaceUserRemoveInput {
  userId: String!
}

